
----------------------------------------------------------------------------------------------------

推广的时候，低调，说现在基于EOS，以后有了类似功能的链，再迁移过去。

----------------------------------------------------------------------------------------------------

梦想现实笔记，EOS账户、智能合约、前端都原样保留，独立存在的自留地。

----------------------------------------------------------------------------------------------------

历史，2018年开始到现在5年时间，如果基于eth是赚10倍，而现在基于eos是损失10倍。总体来说是100倍的差距。做了2个dapp大家看看吧。
支持三个链的原生账户或者地址。有了用户和密码之后，如果有中心化服务器，那么发到arweave的可以使用arseeding由服务器代发，如果没有中心化的服务器，那么发到arweave的使用eth上的everpay代为付费发送。发到eth的由用户使用钱包自己签名发。做好之后，一边推广一边申请三个链的grant。
以后实现只有经过了真人认证的才可以领取贴子中发放的token。

登录可以选择eos原生账户或者用户密码。发到arweave可以选择使用arconnect原生地址、eth上的metamask+everpay代发、服务器代发。发到eth的只能使用metamask来发。

----------------------------------------------------------------------------------------------------

第一步做到：原生账户不能领钱，只有name可以领钱。第二步做到：只有经过真人认证的name才可以领钱。

使用name和密码功能进行发送，如果遇到处在未登录状态而报错时，登录后可以断点续传。

----------------------------------------------------------------------------------------------------

如果有多个系统共用相同的name和密码，则这些系统需要有各自独立的登录状态。

为name设置密码时，客户端需要用name的owner的某个密钥对发出的请求进行签名，通过https将请求发送到服务器端，服务器端检验过签名后，才可以把密码hash存入数据库，再返回成功信息。加上签名和检验签名的动作，以防可以随便设置任何一个name的密码，只有name的owner才可以设置name的密码。

----------------------------------------------------------------------------------------------------

提问：开发了一个基于EOS的智能合约和dapp，如何才能为一个EOS原生账户设置一个密码，可以使用EOS原生账户和对应的这个密码登录dapp，在dapp中调用智能合约的各个功能？

提问：在一个智能合约中能否查询另一个智能合约的multi index table中的数据？

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

                    以下是与  使用用户名和密码登录使用  有关的内容：

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

删除名称的时候，同时删掉绑定关系。
用户名密码系统实际上就是由.ag账户在操作，前端只是在显示的时候进行了对应，合约中不需要查询别的合约中的数据。

两种账务信息：原生账户或与名称对应的.ag账户，实际都是原生账户。
    充值：从原生账户到任意原生账户或任意名称对应的.ag账户。
    提现：从原生账户或名称对应的.ag账户到任意原生账户。
    消费：先充值进账务信息，再消费。
    领钱：领钱进入账务信息，只有名称对应的.ag账户可以领钱。
    点赞、踩：原生账户与名称对应的.ag账户都可以。
    打赏：本身属于消费。如果是打赏柚子，则打赏进入账务信息。如果打赏其他，则显示对应有解析的地址。

----------------------------------------------------------------------------------------------------

提前创建多个.ag账号，并且设置owner里面的ns@eosio.code，给每个账号转入1EOS（或者0.3EOS，可以不被3级名称薅羊毛），将每个账号加入到ns合约的绑定表中，待用。

首先创建ag账号，然后由ag账号创建.ag账号。

建立shell目录和两个子目录：dev和prod，分别存放脚本和文件。

a_target_accounts.txt   待处理的目标账号列表，多行文本文件，每行一个账号。aaaaaaaaa.ag
b_my_env.sh             保存cleoslocal别名、公钥、Token字符串等信息。由别的脚本文件进行source引入。
c_create_account.sh     创建
d_set_eosio_code.sh     设置
e_transfer_token.sh     转入
f_add_to_bind_table.sh  加入
g_query.sh              查看

----------------------------------------------------------------------------------------------------

用户设置密码，需要首先验证发起请求的是名称的真实的拥有者，有两种验证方法：
1. 名称和密码要由名称的owner进行数字签名，再发送到服务端，服务端验证数字签名。此方法实现起来比较难，所以使用的是下面的第2种方法。
2. 步骤如下：
    第一次交互：
        用户端发起请求，准备设置密码，向服务端上传名称和随机的client_check_code。服务端需要检查名称是否存在，如果不存在，则返回错误信息。
        服务端收到请求，生成随机的server_check_code，保存名称、client_check_code、server_check_code，并返回server_check_code。
        用户端收到server_check_code，用户端发送交易，合约处理交易，为名称绑定一个没有被绑定的.ag账号，并且将hash(client_check_code+server_check_code)保存到绑定表中的check_code_hash字段。
    第二次交互：
        几秒钟后，用户端发送设置密码的请求，向服务端上传名称、密码hash、client_check_code。
        服务端检查此名称是否有对应的client_check_code和server_check_code。如果没有，则说明此次请求跳过了第一次交互，是非法请求，直接返回错误信息。如果有，则继续进行下面的步骤。
        服务端检查收到的client_check_code是否与保存的client_check_code一致。如果不一致，则说明同时存在多次请求或者多次交互，发生了错乱，直接返回错误信息，并且清除服务端保存的client_check_code和server_check_code。如果一致，则继续进行下面的步骤。
        服务端生成hash(client_check_code+server_check_code)，与名称对应的智能合约中的绑定表中的check_code_hash字段内容进行对比。
            如果不一致，则说明这是虚假的用户在冒充名称的拥有者设置密码，直接返回错误信息，并且清除服务端保存的client_check_code和server_check_code。
            如果一致，则说明这是名称的真正的拥有者在设置密码，则继续进行下面的步骤。

服务端清除为名称保存的client_check_code和server_check_code，服务端为名称生成：随机数1、随机数2、随机数3，保存hash（密码hash+随机数1），给客户端返回随机数2和3。
客户端保存hash（密码hash+随机数2），然后hash（hash（密码hash+随机数2）+随机数3），以此hash作为种子，产生密钥对。
客户端发送交易，合约处理交易，修改名称对应的.ag账号的active公钥为上一步产生的公钥，并且清除名称对应的智能合约中的绑定表中的check_code_hash字段内容。
为了防止被薅羊毛，3级名称不可以设置密码，需要在合约和服务端两个地方做检查。（如果每个.ag账户只存入0.3EOS，则不需要这个限制。）

用户使用名称和密码登录，服务端验证密码是否正确，如果正确，则返回随机数2和JWT。
客户端保存hash（密码hash+随机数2），不保存随机数2，保存JWT。

用户获取随机数3，服务端验证JWT，正确则返回随机数3。
客户端进行hash（hash（密码hash+随机数2）+随机数3），以此hash作为种子，产生密钥对，保存私钥到js变量。
注意，在用户首次设置密码或者后来修改密码的时候，有一个字段标明了密码的更新时间点。验证JWT的时候，需要检查JWT的签发时间如果在这个更新时间点之前，则说明用户修改了密码，用户需要使用新密码重新登录。

用户发送交易时判断用户是使用原生账号还是名称，如果是使用名称和密码登录后发送交易，则检查cookie中是否有hash（密码hash+随机数2）和JWT。如果都有，则直接到下一步。如果缺少任意一个，则提示用户需要先进行名称密码登录操作。用户登录之后可以进行断点续传。
用户登录状态正常后，检查js中是否有私钥。如果有，则直接签名发送交易。如果没有，则先进行用户获取随机数3的动作，成功后保存私钥到js变量中，接着就可以签名发送交易。

为用户代付CPU/NET，现在可以在用户发送交易前，先执行购买资源的操作，然后再发送交易。每个名称绑定的.ag账号有0.3EOS，可以发送很多次交易。
这个需要在公共测试网上进行测试，到时要在公共测试网上面建立所需的测试账号等等测试环境，需要了解如何在测试网上面创建ag账号和.ag账号。
为了防止被薅羊毛，3级名称不可以设置密码，需要在合约和服务端两个地方做检查。（如果每个.ag账户只存入0.3EOS，则不需要这个限制。）

----------------------------------------------------------------------------------------------------

本次先不实现用户名和密码的功能，下一个版本再实现。

----------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
